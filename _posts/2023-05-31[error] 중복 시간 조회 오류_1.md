### 기존 방식

  - 입력된 시간 범위를 배열로 저장합니다.
- 배열을 시작 시간을 기준으로 정렬합니다.
- 겹치는 시간대를 저장할 빈 배열을 만듭니다.
- 배열의 첫 번째 요소를 선택하고, 현재의 시작 시간과 끝 시간을 변수에 저장합니다.
- 배열을 순회하면서 현재의 끝 시간과 다음 요소의 시작 시간을 비교합니다.
	- 겹치는 경우: 현재의 끝 시간을 다음 요소의 끝 시간과 비교하여 더 큰 값을 저장합니다.
	- 겹치지 않는 경우: 현재의 시작 시간과 끝 시간을 겹치는 시간대 리스트에 추가하고, 현재 요소를 새로운 시작 시간으로 설정합니다.
- 반복문이 종료되면 마지막으로 선택된 시간 범위를 겹치는 시간대 리스트에 추가합니다.
- 겹치는 시간대 리스트를 출력합니다.
  - 슬라이딩 윈도우 기법으로 범위 계산으로 O(nlogn) 의 시간복잡도를 가진다.

<br>

### 문제(오류)

  - 예시) 입력된 시간이 다음과 같으면 07:00~12:00, 07:00~09:00, 10:00~12:00 
  - 예상 출력 리스트 -&gt; 07:00~09:00 (member 1, 2), 10:00~12:00 (member 1, 2)
  - 실제 출력 리스트 -&gt; 07:00~09:00 (member 1, 2)

<br>

### 원인

- 배열을 순회하면서 겹치지 않는 경우 형재 요소를 새로운 시작 시간(기준)으로 바뀌는게 문제

  - 입력한 시간이 중간에 겹치지 않는 부분이 생기면 직전의 겹치는 경우만 리스트로 반환한다.

  - 다음 최대 중첩은 생략된다.

<br>

### 해결 방안

  - 탐색시 시간 기준을 0시부터 24시로 변경
  - 0시부터 24시까지 30분 단위로 탐색한다.
	- 시작 시각부터 모임 소요 시간의 범위 내에 있으면 그룹원을 추가한다.
	- 시작 시각부터 모임 소요 시간의 범위 내에서 벗어나면 그룹원을 삭제한다.
  - 시작 시각부터 모임 소요 시간의 범위, 그룹원 리스트를 저장한다.
  - 그룹원의 인원수가 많은 순으로 내림차순 정렬한다. 만약 같다면 빠른 시작 시간순

<br>

### 해결

  - 예상 출력 리스트 -&gt; 07:00~09:00 (member 1, 2), 10:00~12:00 (member 1, 2)
  - 실제 출력 리스트 -&gt; 07:00~09:00 (member 1, 2), 10:00~12:00 (member 1, 2)
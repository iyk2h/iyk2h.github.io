JVM은 바이트코드를 유연하게 생성할 수 있도록 제공해 준다. 즉 컴파일된 바이트코드를 조작하여 내가 원하는 동작을 하도록 만들 수 있다.



아래는 바이트코드 조작 라이브러리들이다.

- ASM
- Javassist
- ByteBuddy
- CGLib (Code Generator Library)
- JaCoCo



### 여기서 JaCoCo는 어떻게 만들어졌는지 알아보자.



JaCoCo는 Java 코드의 커버리지를 체크하는 라이브러리이다. 테스트코드를 돌리고 그 커버리지 결과를 눈으로 보기 좋도록 html이나 xml, csv 같은 리포트로 생성해 준다. 커버리지 기준을 설정할 수 있다.



JaCoCo는 바이트코드 조작 라이브러리를 사용해 Java 코드를 하나도 건드리지 않고 커버리지를 확인하고 동작할 수 있다.



### 코드 커버리지란

테스트 케이스를 진행하면서 코드 자체가 얼마나 실행되었는지에 대한 수치를 나타내는 지표 중 하나이다.



### 코드 커버리지는 어떻게 측정할까?

- 블랙박스 테스트
	\- 소프트웨어의 내부 구조, 원리를 모르는 상태에서 동작을 검사하는 방식
	\- 사용자 관점의 테스트. 이상한 값을 입력했을 때 올바른 출력이 나오는가?

	

- 화이트박스 테스트
	\- 응용 프로그램의 내부 구조와 동작을 검사하는 테스트 방식.
	\- 개발자의 관점에서 소프트웨어 내부의 소스코드를 테스트



### 코드 커버리지를 측정하는 기준값은?

- 구문(Statement) 또는 라인(Line)

	- 조건에 따른 로직(시나리오)을 확인할 수는 없지만, 모든 코드가 실행되는지 확인 가능한 지표

	- ```java
		// 4개의 라인중 3개가 실행됐다면 구문 커버리지는 75% (3/4)
		void foo (int x) {
		    system.out("start"); // 테스트 1번
		    if (x > 0) { // 테스트 2번
		        system.out("middle"); // 테스트 3번
		    }
		    system.out("last"); // 테스트 4번
		}
		```

- 조건(Condition) 커버리지

	- 조건문 내부조건(if)이 이상한 값이 아닌지 true, false를 반환하는지 확인 가능한 지표

	- ```java
		// 조건이 의미없는 경우(무조건 true)도 테스트 성공으로 표기한다는 단점이 있다.
		void foo (int x, int y) {
		    system.out("start");
		    if (x > 0 && y < 0) { // 테스트. x,y 여러값을 대입하며 true or false가 나오는지 확인한다.
		        system.out("middle");
		    }
		    system.out("last");
		}
		```

- 결정(Decision) 커버리지 또는 브렌치(Branch) 커버리지

	-  테스트에 대해서 모든 조건식이 true, false를 둘 다 가져야 한다. 즉 로직에 따라 실행흐름이 변하는지 확인 가능한 지표
	- 단 조건문이 없으면 아예 테스트를 하지 않는다는 단점이 있다.

- 주로 사용하는 커버리지는 라인 커버리지



### 코드 커버리지가 중요한가?

테스트 코드는 발생할 수 있는 모든 시나리오에 대해 작성되어야 한다. 코드 커버리지를 통한 수치는 개발자가 놓친 로직의 흐름이나 코드를 보완할 수 있게 만들어준다.



코드 커버리지 도구중 소나큐브(SonarQube)와 같은 정적 코드 분석도구는 코드 커버리지값이 기존보다 떨어지는 경우 커밋자체가 불가능하게 제한할 수 있다.


# 팩토리 패턴(factory pattern)



### 팩토리 패턴을 사용하는 이유

다형성은 높이고 의존성 낮추기 위해서이다.



new 연산자를 사용해 인스턴스를 구현하면 나중에 코드를 수정해야 할 가능성이 커지고, 유연성이 떨어집니다. 그래서 상위 형식에 맞춰서 프로그래밍합니다. (인터페이스에 맞춰서 프로그래밍한다.)

<img src="../images/image-20230111113358454.png" alt="image-20230111113358454" style="zoom:50%;" />

>실제 실행 시에 쓰이는 객체가 코드에 공정되지 않도록 상위 형식(supertype)에 맞춰 프로그래밍해서 다형성을 활용해야 한다는 점
>
>변수를 선언할 때 보통 추상 클래스나 인터페이스 같은 상위 형식으로 선언해야 한다. 객체를 변수에 대입할 때 상위 형식을 구체적으로 구현한 형식이라면 어떤 객체든 넣을 수 있기 때문이다. 그러면 "변수를 선언하는 클래스에서 실제 객체의 형식을 몰라도 된다"라는 뜻으로 생각하면 된다.
>
>출처 : 헤드 퍼스트 디자인 패턴

구상 클래스 형식에 맞춰서 프로그래밍

```java
Dog d = new Dog(); // 변수 d를 Dog 형식(Animal을 확장한 구상 클래스)으로 선언하면
d.dark();					 // 구체적인 구현에 맞춰서 코딩해야 한다.
```

인터페이스와 상위 형식에 맞춰서 프로그래밍

```java
Animal animal = new Dog(); //Dog라는 걸 알고 있긴 하지만 다형성을
animal.makeSound(); 			 //활용해서 Animal의 래퍼런스를 써도 된다.
```

더 바람직한 방법으로 상위 형식의 인스턴스를 만드는 과정을 new Dog()같은 식으로 직접 코드로 만드는 대신 구체적으로 구현된 객체를 실행시에 대입하는 것이다.

```java
anumal = getAnimal();
a.makeSound();
```

> 출처 : 헤드 퍼스트 디자인 패턴



## Simple Factory 

디자인 패턴이라기 보다는 프로그래밍에서 자주 쓰이는 광용구에 가깝다. 팩토리 패턴이라고 부르는 사람들도 있다.



피자 가게를 운영한다고 가정

```java
Pizza orderPizza() {
  Pizza pizza = new Pizza();
  
  pizza.prepare();
  pizza.bake();
  return pizza;
}
```



피자 종류가 여러개라면?

```java
Pizza orderPizza(String type) {
  Pizza pizza;
  
  if (type.equlas("cheese")) {
    pizza = new ChesePizze();
  } else if (type.equlas("pepperoni")) {
    pizza = new PepperoniPizze();
  } else if (type.equlas("veggie")) {
    pizza = new VeggiePizze();
  }
  
  pizza.prepare();
  pizza.bake();
  return pizza;
}
```



피자 메뉴를 수정한다면? 기존 메뉴 하나를 제외하고 신메뉴 2개 추가

```java
Pizza orderPizza(String type) {
  Pizza pizza;
  
  if (type.equlas("cheese")) {
    pizza = new ChesePizze();
  } else if (type.equlas("pepperoni")) {
    pizza = new PepperoniPizze();
//  } else if (type.equlas("veggie")) {
//    pizza = new VeggiePizze();
  } else if (type.equlas("clam")) {
    pizza = new ClamPizze();
  } else if (type.equlas("greek")) {
    pizza = new GreekPizze();
  }
  
  pizza.prepare();
  pizza.bake();
  return pizza;
}
```

orderPizza클래스에서 문제되는 부분은 객체 생성 부분이다. + 의존성



객체 생성 부분 캡슐화

```java
public class PazzaStore {
  SimplePazzaFactory factory;

  public PizzaStore(SimplePizzaFacory factory) {
    this.factory = factory;
  }

  Pizza orderPizza(String type) {
    Pizza pizza;

    pizza = factory.createPizza(type);

    pizza.prepare();
    pizza.bake();
    return pizza;
  }
  ...
}
```

```java
// 피자 객체를 생성하는 팩토리. 이 애플리케이션에서 유일하게 객체 생성 Pizza 클래스를 직접 참조하는 부분
public class SimplePizzaFactory {
  
  public Pizza createPizza(String type){ // 팩토리에서 만드는 피자
    Pizza pizza = null;
    
    if (type.equlas("cheese")) {
      pizza = new ChesePizze();
    } else if (type.equlas("pepperoni")) {
      pizza = new PepperoniPizze();
    } else if (type.equlas("clam")) {
      pizza = new ClamPizze();
    } else if (type.equlas("greek")) {
      pizza = new GreekPizze();
    }
    return pizza;
  }
}
```



클래스 다이어그램

![image-20230111084246890](../images/image-20230111084246890.png)



## 팩토리 메소드 패턴(Factory Method Pattern)

객체를 생성할 떄 필요한 인터페이스를 만든다. 어떤 클래스의 인스턴스를 만들지는 서브클래스에서 결정하게 된다.

![image-20230111090345383](../images/image-20230111090345383.png)

Creator에는 제품으로 원하는 일을 할 때 필요한 모든 메소드가 구현되어 있다. 하지만 제품을 만들어 주는 팩토리 메소드는 추상 메소드로 정의되어 있다.

Creator에서 정의된 추상메서드는 ConcreteCreator 에서 factoryMethod()를 구현한다.

Product와 ConcreteCreatr (제품 클래스)는 모두 똑같은 인터페이스를 구현해야 한다. 그래야 그 제품을 사용할 클래스에서 구상 클래스가 아닌 인터페이스의 레퍼런스로 객체를 참조할 수 있기때문이다.



